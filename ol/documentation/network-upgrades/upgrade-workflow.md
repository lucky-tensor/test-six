# Pre-upgrade workflow

## Create a release branch
The assumption is that All CI and integration tests are passing on `main` branch, and the release branch is forked from main.

Release branches are named with the semver version `release-X.Y.Z-beta.A`

## Write the Changelog

The changelog is the document validators will read in order to determine if they will vote on the upgrade. The changelog should be comprehensive about the changes made, and link to all final documentation an pull requests relevant.

The changelog must include the hash of the STDLIB which is generated by the release.

The changelog most importantly needs to define if the the STDLIB is compatible with the current diem-node software being run. And if it is NOT and a diem-node upgrade is necessary first, the procedure must be documented.


## Create a beta release tage
A release must be tagged `x.y.z-beta.a`

## QA the Beta Release on Devnet (Rex)

The network QA needs to run through a standard *manual* QA procedure.

See [steps in the pre-flight-checks](./pre-flight-checks)

## Fix what is broken
On the release branch.

## Merge Release Branch and Tag
Be sure to update the Changelog file with the Hash of the STDLIB if changes have been made since.

Merge the release branch into `main`.

A release must be tagged. It is not `beta` or `alpha`.


## One validator makes a proposal
A validator submits the initial Move bytecode to the network with:

1. Build stdlib (on validator or on a developer machine).

`make stdlib`

2. Send the upgrade tx
`txs oracle-upgrade -v -f <path to sdlib>`


##  Get consensus on the upgrade

The remaining steps are summarized here: See also [what a hot upgrade entails](stdlib-hot-upgrade.md). In summary:

### Announce the proposal

Announce the proposal in customary channels (Discord)

### Wait for votes

Subsequent validators can vote by submitting the binaries, or the hash of the stdlib. If the binaries or the hashes match the original proposers, it is a "concurring" vote.

On the next epoch boundary on the Upgrade Tick (round 2), the VM will trigger a tally of the votes. If there is consensus then a "payload" of the proposers's Move Bytecode is elected.

### Cool off

There is a one epoch cooling off, where the network validators could issue an abort sequence for the upgrade.

### Upgrade
If the upgrade is not aborted then on the next epoch boundary, and the same Upgrade Tick (round 2) the VM bytecode is "flashed" by all validators simultaneously. The diem-node triggers a "writeset" of the Move bytecode onto 0x1.

